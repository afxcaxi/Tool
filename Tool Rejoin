import os
import requests
import json
import time
import re
import subprocess
import GPUtil
import threading
import psutil
from prettytable import PrettyTable
from colorama import init, Fore, Style, Back

init()

SUCCESS_COLOR = '\x1b[92m'
FAILURE_COLOR = '\x1b[91m'
RESET_COLOR = '\x1b[0m'

successful_blocks = 0
failed_blocks = 0
SERVER_LINKS_FILE = "FS-Kryuss_Server-Links.txt"
ACCOUNTS_FILE = "FS-Kryus_Accounts.txt"
status_lock = threading.Lock()
rejoin_lock = threading.Lock()

XfGpdUqYhZt = "https://maomaostore.site/cOKfPjqAYwQF.php"
YsJrLwEvBkC = "/data/data/SKey11.txt"

def YoErTlWqZvM(NbXmYpVoJkL):
    try:
        XeYpWqVrNfM = requests.get(XfGpdUqYhZt, headers={'Authorization': NbXmYpVoJkL})
        if XeYpWqVrNfM.json().get("success"):
            return True
    except requests.RequestException:
        pass
    return False

def KeLpJmNoYvX():
    if os.path.exists(YsJrLwEvBkC):
        with open(YsJrLwEvBkC, "r") as f:
            UhVxYmNpLoK = f.read().strip()
        if YoErTlWqZvM(UhVxYmNpLoK):
            return

    while True:
        NmXpYvLoKqJ = input(Fore.LIGHTCYAN_EX + "üç£ Please Enter Your Key: " + Style.RESET_ALL).strip()
        if YoErTlWqZvM(NmXpYvLoKqJ):
            with open(YsJrLwEvBkC, "w") as f:
                f.write(NmXpYvLoKqJ)
            return

package_statuses = {}
username_cache = {}
CACHE_FILE = "FS-Kryuss_Username-Cache.json"
cache_save_interval = 600  
HaXvNvpmKxOd = "f703e3d6f898de7d"  
HaXvNvpmKxOd = "rjKNlduFqpXblNWlQdkCSBUskzIIwaBR"  

executors = {
    "Arceus X": "/storage/emulated/0/Arceus X/",
    "Codex": "/storage/emulated/0/Codex/",
    "Trigon": "/storage/emulated/0/Trigon/",
    "Vegax": "/storage/emulated/0/Vegax/",
    "Evon": "/storage/emulated/0/Evon/",
    "Cryptic": "/storage/emulated/0/Cryptic/"
}

workspace_paths = {os.path.join(base_path, "Workspace") for base_path in executors.values()}
workspace_paths.update({os.path.join(base_path, "workspace") for base_path in executors.values()})
workspace_paths = list(workspace_paths)

lua_script_template = '''loadstring(game:HttpGet("https://raw.githubusercontent.com/Devionyx11/Entire-Codebase/refs/heads/main/Check%20Executor%20UI"))()'''

def print_header(cpu, ram, gpu):
    os.system('cls' if os.name == 'nt' else 'clear')
    header = r"""
____________________            ____  __.                                  
\_   _____/   _____/           |    |/ _|______ ___.__.__ __  ______ ______
 |    __) \_____  \    ______  |      < \_  __ <   |  |  |  \/  ___//  ___/
 |     \  /        \  /_____/  |    |  \ |  | \/\___  |  |  /\___ \ \___ \ 
 \___  / /_______  /           |____|__ \|__|   / ____|____//____  >____  >
     \/          \/                    \/       \/               \/     \/ 
"""
    print(Fore.LIGHTCYAN_EX + header + Style.RESET_ALL)
    print(Fore.LIGHTMAGENTA_EX + "Sxionax's Discord Is: https://discord.gg/sxionaxcommunity " + Style.RESET_ALL)
    print(Fore.LIGHTWHITE_EX + "Crafted By Kryuss" + Style.RESET_ALL + " | " + Fore.LIGHTYELLOW_EX + "Version: " + Fore.LIGHTGREEN_EX + "Experimental - Premium" + Style.RESET_ALL)
    print(Fore.LIGHTYELLOW_EX + f"CPU Usage: {cpu}%  RAM Usage: {ram}%  GPU Usage: {gpu}%" + Style.RESET_ALL)

def check_system_cpu_ram_gpu():
    cpu = psutil.cpu_percent(interval=1)
    ram = psutil.virtual_memory().percent

    try:
        gpus = GPUtil.getGPUs()
        gpu = gpus[0].memoryUtilization * 100 if gpus else 0 
    except (AttributeError, IndexError):
        gpu = 0  

    return cpu, ram, gpu

def detect_and_write_lua_script():
    detected_executors = []

    for executor_name, base_path in executors.items():
        possible_autoexec_paths = [
            os.path.join(base_path, "Autoexec"),
            os.path.join(base_path, "Autoexecute")
        ]

        for path in possible_autoexec_paths:
            if os.path.exists(path):
                lua_script_path = os.path.join(path, "FS-Kryuss_Check.lua")
                
                try:
                    with open(lua_script_path, 'w') as file:
                        file.write(lua_script_template) 
                    detected_executors.append(executor_name)
                    break

                except Exception as e:
                    print(Fore.LIGHTRED_EX + f"Error Writing LuaU Script!" + Style.RESET_ALL)

    return detected_executors

def reset_executor_file(username):
    status_file = f"FS-Kryuss_{username}.txt"
    valid_workspace = None 

    for executor, base_path in executors.items():
        for workspace_dir in ["workspace", "Workspace"]:
            workspace_path = os.path.join(base_path, workspace_dir)
            if os.path.exists(workspace_path):
                valid_workspace = workspace_path
                break 

        if valid_workspace:
            break  

    if valid_workspace:
        file_path = os.path.join(valid_workspace, status_file)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)  
            except Exception as e:
                print(Fore.RED + f"Error removing file: {e}" + Style.RESET_ALL)

def check_executor_status(username, continuous=False, max_wait_time=240, check_interval=5, max_inactivity_time=30):
    status_file = f"FS-Kryuss_{username}.txt"
    retry_timeout = time.time() + max_wait_time
    active_workspace = None  

    for executor, base_path in executors.items():
        for workspace_dir in ["workspace", "Workspace"]:
            workspace_path = os.path.join(base_path, workspace_dir)
            if os.path.exists(workspace_path):
                active_workspace = workspace_path
                break  

        if active_workspace:
            break 

    if not active_workspace:
        print(f"No valid workspace found for {username}. Skipping executor check.")
        return True  

    start_time = time.time()

    while True:
        file_path = os.path.join(active_workspace, status_file)

        if os.path.exists(file_path):
            last_modified_time = os.path.getmtime(file_path)
            current_time = time.time()

            if current_time - last_modified_time < max_inactivity_time:
                with open(file_path, 'r') as f:
                    content = f.read().strip()

                    if content.startswith("working"):
                        return True  

        if not continuous and time.time() > retry_timeout:
            print(f"Executor check timed out for {username} after {max_wait_time} seconds.")
            return False

        time.sleep(check_interval) 

def create_dynamic_menu(options):
    table = PrettyTable()
    table.field_names = [
        f"{Back.BLUE}{Fore.WHITE} Option {Style.RESET_ALL}",
        f"{Back.MAGENTA}{Fore.WHITE} Description {Style.RESET_ALL}"
    ]
    table.align["Option"], table.align["Description"] = "c", "l"

    for i, option in enumerate(options, start=1):
        table.add_row([
            f"{Fore.LIGHTMAGENTA_EX}{i}{Style.RESET_ALL}",
            f"{Fore.LIGHTGREEN_EX}{option}{Style.RESET_ALL}"
        ])

    print(table)

def create_dynamic_table(headers, rows):
    table = PrettyTable()
    table.field_names = [
        f"{Back.CYAN}{Fore.BLACK} {h} {Style.RESET_ALL}" for h in headers
    ]

    for h in headers:
        table.align[h] = "l"

    for row in rows:
        table.add_row([f"{Fore.LIGHTGREEN_EX}{item}{Style.RESET_ALL}" for item in row])

    print(table)

def update_status_table(package_statuses):
    cpu, ram, gpu = check_system_cpu_ram_gpu()
    print_header(cpu, ram, gpu)

    table = PrettyTable()
    table.field_names = [
        f"{Back.BLUE}{Fore.WHITE} Package {Style.RESET_ALL}",
        f"{Back.MAGENTA}{Fore.WHITE} Username {Style.RESET_ALL}",
        f"{Back.YELLOW}{Fore.BLACK} Status {Style.RESET_ALL}"
    ]

    for col in ["Package", "Username", "Status"]:
        table.align[col] = "l"

    for package, info in package_statuses.items():
        table.add_row([
            f"{Fore.LIGHTBLUE_EX}{package}{Style.RESET_ALL}",
            f"{Fore.LIGHTGREEN_EX}{info.get('Username', 'Unknown')}{Style.RESET_ALL}",
            f"{Fore.LIGHTYELLOW_EX}{info.get('Status', '')}{Style.RESET_ALL}"
        ])

    print(table)

def get_roblox_packages():
    packages = []
    result = os.popen('pm list packages').read()
    
    package_name = re.findall(r'\bcom\.roblox\S*', result)
    
    for package in package_name:
        print(Fore.LIGHTGREEN_EX + f"Found This Package: {package}" + Style.RESET_ALL)
        packages.append(package)
        
    return packages

def is_roblox_running(package_name):
    try:
        package_name = package_name.lower()
        for p in psutil.process_iter(['name']):
            process_name = p.info.get('name', '')
            if process_name and package_name in process_name.lower():
                return True
        return False
    except psutil.Error as e:
        print(ore.LIGHTGREEN_EX + f"Error Checking Process, Please Try Again!" + Style.RESET_ALL)
        return False

def kill_roblox_processes():
    print("Killing all Roblox processes...")
    package_names = get_roblox_packages()
    for package_name in package_names:
        print(f"Trying to kill process for package: {package_name}")
        result = subprocess.run(["pkill", "-f", package_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode == 0:
            print(f"Successfully killed process for {package_name}")
        else:
            print(f"Failed to kill process for {package_name}: {result.stderr.decode()}")
    time.sleep(1) 

def kill_roblox_process(package_name):
    print(f"Killing Roblox process for {package_name}...")
    result = subprocess.run(["pkill", "-f", package_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if result.returncode == 0:
        print(f"Successfully killed process for {package_name}")
    else:
        print(f"Failed to kill process for {package_name}: {result.stderr.decode()}")
    time.sleep(1) 

def launch_roblox(package_name, server_link, num_packages, package_statuses):
    try:
        package_statuses[package_name]["Status"] = Fore.LIGHTCYAN_EX + f"Opening Roblox for {package_name}..." + Style.RESET_ALL
        update_status_table(package_statuses)

        commands = [
            (['am', 'start', '-n', f'{package_name}/com.roblox.client.startup.ActivitySplash', '-d', server_link], 1),
            (['am', 'start', '-n', f'{package_name}/com.roblox.client.ActivityProtocolLaunch', '-d', server_link], 11)
        ]
        
        for command, sleep_time in commands:
            result = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            if result.returncode != 0:
                print(f"Error running command {command}: {result.stderr.decode()}")
            time.sleep(sleep_time)
        
        package_statuses[package_name]["Status"] = Fore.GREEN + "Joined Roblox" + Style.RESET_ALL
        update_status_table(package_statuses)

    except Exception as e:
        package_statuses[package_name]["Status"] = Fore.RED + f"Error launching Roblox for {package_name}: {e}" + Style.RESET_ALL
        update_status_table(package_statuses)
        print(f"Error details: {e}")

def check_executor_and_rejoin(package_name, username, package_statuses, server_link, num_packages, accounts):
    try:
        detected_executors = detect_and_write_lua_script()

        if detected_executors:
            print(f"Checking executor status for {package_name} with username {username}...")

            start_time = time.time()
            executor_loaded = False
            while time.time() - start_time < 120:
                if check_executor_status(username):
                    package_statuses[package_name]["Status"] = Fore.GREEN + f"Executor loaded successfully for {username}" + Style.RESET_ALL
                    executor_loaded = True
                    break
                time.sleep(10)

            if not executor_loaded:
                print(f"Executor did not load for {package_name} (username: {username}). Rejoining...")
                package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                update_status_table(package_statuses)

                kill_roblox_process(package_name)
                time.sleep(2)
                launch_roblox(package_name, server_link, num_packages, package_statuses)
                check_executor_and_rejoin(package_name, username, package_statuses, server_link, num_packages, accounts)
        else:
            print(f"No executor detected for {package_name} (username: {username}).")
            package_statuses[package_name]["Status"] = Fore.GREEN + f"Joined without executor for {username}" + Style.RESET_ALL
            update_status_table(package_statuses)

        monitor_thread = threading.Thread(target=background_executor_monitor, args=(package_name, username, package_statuses, server_link, num_packages))
        monitor_thread.daemon = True
        monitor_thread.start()

    except Exception as e:
        package_statuses[package_name]["Status"] = Fore.RED + f"Error checking executor for {package_name}: {e}" + Style.RESET_ALL
        update_status_table(package_statuses)

def background_executor_monitor(package_name, username, package_statuses, server_link, num_packages, retry_limit=3):
    retry_count = 0

    try:
        while retry_count < retry_limit:
            if not check_executor_status(username, continuous=False):
                retry_count += 1
                package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                update_status_table(package_statuses)
                
                with rejoin_lock:
                    kill_roblox_process(package_name)
                    time.sleep(5)
                    launch_roblox(package_name, server_link, num_packages, package_statuses)
                    time.sleep(120)

                if check_executor_status(username, continuous=False):
                    retry_count = 0
                    package_statuses[package_name]["Status"] = Fore.GREEN + "Executor reloaded successfully after rejoin." + Style.RESET_ALL
                    update_status_table(package_statuses)
                else:
                    package_statuses[package_name]["Status"] = Fore.RED + "Executor still failed after rejoin, retrying..." + Style.RESET_ALL
                    update_status_table(package_statuses)

            else:
                package_statuses[package_name]["Status"] = Fore.GREEN + "Executor is working fine." + Style.RESET_ALL
                update_status_table(package_statuses)
                break

            time.sleep(30)

        if retry_count >= retry_limit:
            package_statuses[package_name]["Status"] = Fore.RED + "Reached retry limit, stopping rejoin attempts..." + Style.RESET_ALL
            update_status_table(package_statuses)

    except Exception as e:
        package_statuses[package_name]["Status"] = Fore.RED + f"Error in background monitor: {e}" + Style.RESET_ALL
        update_status_table(package_statuses)

def get_game_name(game_link_or_id):
    try:
        # Extract the game ID from the link if it's a URL
        if 'roblox.com' in game_link_or_id:
            game_id = game_link_or_id.split('/')[-1]
        else:
            game_id = game_link_or_id

        # Make a request to the Roblox API to get game details
        url = f"https://games.roblox.com/v1/games?universeIds={game_id}"
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            game_data = response.json()
            if game_data['data']:
                return game_data['data'][0]['name']
            else:
                return "Unknown Game"
        else:
            return "Failed to retrieve game name"
    except Exception as e:
        print(Fore.RED + f"Error retrieving game name: {e}" + Style.RESET_ALL)
        return "Error"
        
# Function to format server link
def format_server_link(input_link):
    if 'roblox.com' in input_link:
        return input_link
    elif input_link.isdigit():
        return f'roblox://placeID={input_link}'
    else:
        print(Fore.RED + "Invalid input! Please enter a valid game ID or private server link." + Style.RESET_ALL)
        return None

# Function to save server links to file
def save_server_links(server_links):
    with open(SERVER_LINKS_FILE, "w") as file:
        for package, link in server_links:
            file.write(f"{package},{link}\n")

# Function to load server links from file
def load_server_links():
    server_links = []
    if os.path.exists(SERVER_LINKS_FILE):
        with open(SERVER_LINKS_FILE, "r") as file:
            for line in file:
                package, link = line.strip().split(",", 1)
                server_links.append((package, link))
    return server_links

# Function to save accounts to file
def save_accounts(accounts):
    with open(ACCOUNTS_FILE, "w") as file:
        for package, user_id in accounts:
            file.write(f"{package},{user_id}\n")

# Function to load accounts from file
def load_accounts():
    accounts = []
    if os.path.exists(ACCOUNTS_FILE):
        with open(ACCOUNTS_FILE, "r") as file:
            for line in file:
                package, user_id = line.strip().split(",", 1)
                accounts.append((package, user_id))
    return accounts

# Function to find UserId from file
def find_userid_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            # Debugging information removed to keep console clean

            userid_start = content.find('"UserId":"')
            if userid_start == -1:
                print("Userid not found")
                return None

            userid_start += len('"UserId":"')
            userid_end = content.find('"', userid_start)
            if userid_end == -1:
                print("Userid end quote not found")
                return None

            userid = content[userid_start:userid_end]
            return userid

    except IOError as e:
        print(f"Error reading file: {e}")
        return None

# Asynchronous function to get user ID from username
async def get_user_id(username):
    url = "https://users.roblox.com/v1/usernames/users"
    payload = {
        "usernames": [username],
        "excludeBannedUsers": True
    }
    headers = {
        "Content-Type": "application/json"
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=payload, headers=headers) as response:
            data = await response.json()
            if 'data' in data and len(data['data']) > 0:
                return data['data'][0]['id']
    return None

def get_server_link(package_name, server_links):
    return next((link for pkg, link in server_links if pkg == package_name), None)

def get_username_from_id(user_id):
    return get_username(user_id) or user_id
    
# Function to get username from user ID
def get_username(user_id):
    retry_attempts = 2
    for attempt in range(retry_attempts):
        try:
            url = f"https://users.roblox.com/v1/users/{user_id}"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            username = data.get("name", "Unknown")
            if username != "Unknown":
                username_cache[user_id] = username
                save_username(user_id, username)
                return username
        except requests.exceptions.RequestException as e:
            print(Fore.RED + f"Attempt {attempt + 1} failed for Roblox Users API: {e}" + Style.RESET_ALL)
            time.sleep(2 ** attempt)  # Exponential backoff

    # Fallback to RoProxy API
    for attempt in range(retry_attempts):
        try:
            url = f"https://users.roproxy.com/v1/users/{user_id}"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            username = data.get("name", "Unknown")
            if username != "Unknown":
                username_cache[user_id] = username
                save_username(user_id, username)
                return username
        except requests.exceptions.RequestException as e:
            print(Fore.RED + f"Attempt {attempt + 1} failed for RoProxy API: {e}" + Style.RESET_ALL)
            time.sleep(2 ** attempt)  # Exponential backoff

    return "Unknown"

# Example of saving the username in a persistent storage
def save_username(user_id, username):
    try:
        if not os.path.exists("usernames.json"):
            with open("usernames.json", "w") as file:
                json.dump({user_id: username}, file)
        else:
            with open("usernames.json", "r+") as file:
                try:
                    data = json.load(file)
                except json.JSONDecodeError:
                    data = {}
                data[user_id] = username
                file.seek(0)
                json.dump(data, file)
                file.truncate()
    except (IOError, json.JSONDecodeError) as e:
        print(Fore.RED + f"Error saving username: {e}" + Style.RESET_ALL)

# Example of loading the username from persistent storage
def load_saved_username(user_id):
    try:
        with open("usernames.json", "r") as file:
            data = json.load(file)
            return data.get(user_id)
    except (FileNotFoundError, json.JSONDecodeError, IOError) as e:
        print(Fore.RED + f"Error loading username: {e}" + Style.RESET_ALL)
        return None
    
def load_cache():
    global username_cache
    if os.path.exists(CACHE_FILE):
        with open(CACHE_FILE, "r") as f:
            username_cache = json.load(f)

def save_cache():
    try:
        temp_file = CACHE_FILE + ".tmp"
        with open(temp_file, "w") as f:
            json.dump(username_cache, f)
        os.replace(temp_file, CACHE_FILE)  # Atomic move to replace the file
    except IOError as e:
        print(Fore.RED + f"Error saving cache: {e}" + Style.RESET_ALL)

def check_user_online(user_id: int) -> tuple[int | None, str | None]:
    primary_url = "https://presence.roblox.com/v1/presence/users"
    headers = {'Content-Type': 'application/json'}
    payload = {"userIds": [user_id]}

    try:
        with requests.Session() as session:
            response = session.post(primary_url, headers=headers, json=payload, timeout=3)
            response.raise_for_status()  

            data = response.json()
            user_presences = data.get("userPresences", [])

            if not user_presences:
                return None, None

            user_presence = user_presences[0]
            presence_type = user_presence.get("userPresenceType")
            last_location = user_presence.get("lastLocation", "")

            if last_location == "Website":
                presence_type = 0

            return presence_type, last_location

    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Request failed for user {user_id}: {e}")
    except requests.exceptions.JSONDecodeError as e:
        print(f"[ERROR] JSON decoding error for user {user_id}: {e}")
    except Exception as e:
        print(f"[ERROR] Unexpected error for user {user_id}: {e}")

    return None, None

def check_cookie_validity(cookie):
    url = "https://users.roblox.com/v1/users/authenticated"
    headers = {
        "Cookie": f".ROBLOSECURITY={cookie}",
        "User-Agent": "Mozilla/5.0",
        "Content-Type": "application/json"
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        print(f"{Fore.GREEN}Cookie is alive!")
        user_data = response.json()
        print(f"Logged in as: {user_data['name']} (User ID: {user_data['id']})")
        return True
    elif response.status_code == 401:
        print(f"{Fore.RED}Cookie is dead or invalid!")
        return False
    else:
        print(f"{Fore.YELLOW}Unexpected response. Status Code: {response.status_code}")
        print(f"Response: {response.text}")
        return False

def check_cookies_from_file(file_path):
    folder_name = "Cookies Checked"
    if not os.path.exists(folder_name):
        os.makedirs(folder_name)
    
    live_file_path = os.path.join(folder_name, 'live.txt')
    dead_file_path = os.path.join(folder_name, 'dead.txt')
    
    if not os.path.exists(file_path):
        print(f"{Fore.RED}File {file_path} doesn't exist. Creating one...")
        with open(file_path, 'w') as file:
            file.write("") 
        print(f"{Fore.GREEN}Created {file_path}. Add cookies in it with 'cookie' format and try again!")
        return
    
    with open(file_path, 'r') as file:
        cookies = file.readlines()

    open(live_file_path, 'w').close()  # Clear live.txt
    open(dead_file_path, 'w').close()  # Clear dead.txt
    
    total_cookies = len(cookies)
    live_cookies = 0
    dead_cookies = 0
    
    for idx, cookie in enumerate(cookies, 1):
        cookie = cookie.strip()
        
        if cookie:  # Ensure the line isn't empty
            print(f"Checking cookie {idx}...")
            
            if check_cookie_validity(cookie):  
                live_cookies += 1
                with open(live_file_path, 'a') as live_file:
                    live_file.write(f"{cookie}\n")
            else:  
                dead_cookies += 1
                with open(dead_file_path, 'a') as dead_file:
                    dead_file.write(f"{cookie}\n")
        else:
            print(f"{Fore.RED}Invalid format in line {idx}. Expected format 'cookie'.")

    print(f"--------------------------------------------------")
    print(f"\n{Fore.CYAN}Total Cookies: {total_cookies}")
    print(f"{Fore.GREEN}Live Cookies: {live_cookies}")
    print(f"{Fore.RED}Dead Cookies: {dead_cookies}")

def extract_error_message(response):
    try:
        return response.json()['errors'][0]['message']
    except:
        return 'Not Found'

def get_userid_from_cookie(session, cookie, userids):
    try:
        response = session.get(
            'https://users.roblox.com/v1/users/authenticated',
            cookies={'.ROBLOSECURITY': cookie},
            timeout=3
        )
        user_data = response.json()
        with lock:
            userids.append(user_data.get('id'))
    except requests.exceptions.RequestException as e:
        print(f"{FAILURE_COLOR}Failed to retrieve user ID: {e}{RESET_COLOR}")

def block_users(session, cookie, userids):
    global successful_blocks, failed_blocks

    try:
        response = session.post(
            'https://auth.roblox.com/v2/login',
            cookies={'.ROBLOSECURITY': cookie},
            timeout=3
        )
        csrf_token = response.headers.get('X-CSRF-TOKEN', '')

        names = session.get(
            'https://users.roblox.com/v1/users/authenticated',
            cookies={'.ROBLOSECURITY': str(cookie).strip()},
            timeout=3
        )
        name = names.json().get('name', 'Not Found')

        for userid in userids:
            try:
                response = session.post(
                    f'https://accountsettings.roblox.com/v1/users/{userid}/block',
                    cookies={'.ROBLOSECURITY': cookie},
                    headers={'X-CSRF-TOKEN': csrf_token},
                    timeout=3
                )

                with lock:
                    if response.status_code == 200:
                        successful_blocks += 1
                        print(f"{SUCCESS_COLOR}‚úì SUCCESS: Account '{name}' blocked user with ID {userid}{RESET_COLOR}")
                    else:
                        failed_blocks += 1
                        error_message = extract_error_message(response)
                        print(f"{FAILURE_COLOR}‚úó FAILURE: Account '{name}' could not block user with ID {userid}")
                        print(f'    Reason: {error_message}{RESET_COLOR}')

            except requests.exceptions.RequestException as e:
                print(f"{FAILURE_COLOR}Request error: {e}{RESET_COLOR}")

    except requests.exceptions.RequestException as e:
        print(f"{FAILURE_COLOR}Failed to authenticate: {e}{RESET_COLOR}")

def block_worker(cookie, userids):
    with requests.Session() as session:
        block_users(session, cookie, userids)

def user_id_worker(cookie, userids):
    with requests.Session() as session:
        get_userid_from_cookie(session, cookie, userids)

def block_accounts():
    start_time = datetime.now()

    if not os.path.exists('cookie.txt'):
        print(f"{FAILURE_COLOR}Error: 'cookie.txt' file not found!{RESET_COLOR}")
        return

    with open('cookie.txt', 'r') as file:
        cookies = []
        for line in file:
            parts = line.strip().split(':')
            if len(parts) == 4:
                cookies.append(':'.join(parts[2:]))
            else:
                cookies.append(line.strip())

    # Helper to divide cookies into chunks
    def chunkify(lst, chunk_size):
        for i in range(0, len(lst), chunk_size):
            yield lst[i:i + chunk_size]

    cookie_chunks = list(chunkify(cookies, 100))
    userids = []

    for chunk in cookie_chunks:
        userids = []
        threads = []

        for cookie in chunk:
            t = threading.Thread(target=user_id_worker, args=(cookie, userids))
            t.start()
            threads.append(t)

        for t in threads:
            t.join()

        threads = []

        for cookie in chunk:
            t = threading.Thread(target=block_worker, args=(cookie, userids))
            t.start()
            threads.append(t)

        for t in threads:
            t.join()

    end_time = datetime.now()
    elapsed_time = end_time - start_time

    print(f'{SUCCESS_COLOR}Total successful blocks: {successful_blocks}{RESET_COLOR}')
    print(f'{FAILURE_COLOR}Total failed blocks: {failed_blocks}{RESET_COLOR}')
    print(f'Time: {elapsed_time.total_seconds():.2f} seconds. Total cookies: {len(cookies)}')

def smdgEjeejCgh():
    try:
        subprocess.run(["settings", "put", "secure", "android_id", HaXvNvpmKxOd], check=True, capture_output=True)
        print(Fore.LIGHTGREEN_EX + "Same HWID Has Been Successfully Set For Your Device!" + Style.RESET_ALL)
    except Exception as e: 
        print(Fore.LIGHTRED_EX + "Error Occurred!" + Style.RESET_ALL)
    
    input(Fore.LIGHTCYAN_EX + "üî• Click Here To Continue To The Next Step.... üìû" + Style.RESET_ALL)
    BqIjwGnTqBtd()

def BqIjwGnTqBtd():
    ZbXmLqYvNpK = "/storage/emulated/0/Cryptic/Workspace/cryptic_key.DEPOSIBLE"
    try:
        os.makedirs(os.path.dirname(ZbXmLqYvNpK), exist_ok=True)
        with open(ZbXmLqYvNpK, "w") as f:
            f.write(HaXvNvpmKxOd)
        print(Fore.GREEN + "Cryptic's Key Successfully Made Permanent For Your Device!" + Style.RESET_ALL)
    except Exception as e:
        print(Fore.RED + "Error Occurred!" + Style.RESET_ALL)
    
    input(Fore.LIGHTCYAN_EX + "üî• Press Enter To Go Back Main Menu... üìû" + Style.RESET_ALL)
    main()

def main():
    KeLpJmNoYvX()

    load_cache()

    cpu, ram, gpu = check_system_cpu_ram_gpu()
    print_header(cpu, ram, gpu)
    while True:
        cpu, ram, gpu = check_system_cpu_ram_gpu()
        print_header(cpu, ram, gpu)

        menu_options = [
            "Start Auto Rejoin Roblox Game",
            "Same Game ID Or Private Server Link",
            "Different Private Server Or Game ID",
            "Clear User IDs And/Or Private Server Links",
            "Automatically Set Up User ID For Roblox Games",
            "Check Cookie",
            "Auto Same HWID",
            "Exit"
        ]

        create_dynamic_menu(menu_options)

        setup_type = input(Fore.LIGHTMAGENTA_EX + "Enter choice: " + Style.RESET_ALL)

        if setup_type == "1":
            while True:
                disable_check_executor = input(Fore.CYAN + "Do You Want to Disable Executor UI Checking? (y/n): " + Style.RESET_ALL).strip().lower()

                if disable_check_executor == "y":
                    server_links = load_server_links()
                    accounts = load_accounts()

                    if not accounts:
                        print(Fore.RED + "No user IDs set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                        continue
                    elif not server_links:
                        print(Fore.RED + "No game ID or private server link set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                        continue

                    try:
                        force_rejoin_interval = int(input("Enter the force rejoin/kill Roblox interval in minutes: ")) * 60
                        if force_rejoin_interval <= 0:
                            raise ValueError("The interval must be a positive integer.")
                    except ValueError as ve:
                        print(Fore.RED + f"Invalid input: {ve}. Please enter a valid interval in minutes." + Style.RESET_ALL)
                        input(Fore.GREEN + "Press Enter to return to the menu..." + Style.RESET_ALL)
                        continue

                    package_statuses = {}
                    for package_name, server_link in server_links:
                        package_statuses[package_name] = {
                            "Status": Fore.LIGHTCYAN_EX + "Initializing" + Style.RESET_ALL,
                            "Username": get_username(accounts[server_links.index((package_name, server_link))][1]),
                        }

                    update_status_table(package_statuses)

                    # Kill Roblox processes and wait for 5 seconds
                    kill_roblox_processes()
                    time.sleep(5)

                    num_packages = len(server_links)

                    for package_name, server_link in server_links:
                        try:
                            package_statuses[package_name]["Status"] = Fore.LIGHTCYAN_EX + "Launching" + Style.RESET_ALL
                            update_status_table(package_statuses)
                            launch_roblox(package_name, server_link, num_packages, package_statuses)
                            package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL
                        except Exception as e:
                            print(Fore.RED + f"Error launching Roblox for {package_name}: {e}" + Style.RESET_ALL)
                            package_statuses[package_name]["Status"] = Fore.RED + "Launch failed" + Style.RESET_ALL
                        update_status_table(package_statuses)

                    start_time = time.time()

                    while True:
                        current_time = time.time()

                        try:
                            for package_name, user_id in accounts:
                                try:
                                    server_link = get_server_link(package_name, server_links)
                                    if not server_link:
                                        package_statuses[package_name]["Status"] = Fore.RED + "Server link not found" + Style.RESET_ALL
                                        update_status_table(package_statuses)
                                        continue

                                    username = get_username_from_id(user_id)
                                    presence_type, last_location_current = check_user_online(user_id)

                                    package_statuses[package_name]["Username"] = username

                                    if presence_type == 2:
                                        package_statuses[package_name]["Status"] = Fore.GREEN + "In-Game" + Style.RESET_ALL
                                    else:
                                        if not is_roblox_running(package_name):
                                            package_statuses[package_name]["Status"] = Fore.RED + "Process Crashed, Relaunching" + Style.RESET_ALL
                                            kill_roblox_process(package_name)
                                            time.sleep(2)
                                            launch_roblox(package_name, server_link, num_packages, package_statuses)
                                        else:
                                            if last_location_current == "Website":
                                                package_statuses[package_name]["Status"] = Fore.RED + "On Website, Rejoining" + Style.RESET_ALL
                                                kill_roblox_process(package_name)
                                                time.sleep(2)
                                                launch_roblox(package_name, server_link, num_packages, package_statuses)
                                            else:
                                                package_statuses[package_name]["Status"] = Fore.YELLOW + "Not In-Game, Recently Active" + Style.RESET_ALL

                                    update_status_table(package_statuses)
                                    time.sleep(25)

                                except Exception as e:
                                    print(Fore.RED + f"Error during rejoin process for {package_name}: {e}" + Style.RESET_ALL)
                                    package_statuses[package_name]["Status"] = Fore.RED + "General error" + Style.RESET_ALL
                                    update_status_table(package_statuses)

                            if current_time - start_time >= force_rejoin_interval:
                                print("Force killing Roblox processes due to time limit.")
                                kill_roblox_processes()
                                start_time = current_time
                                print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
                                time.sleep(5)
                                for package_name, server_link in server_links:
                                    try:
                                        package_statuses[package_name]["Status"] = Fore.RED + "Rejoining" + Style.RESET_ALL
                                        update_status_table(package_statuses)
                                        launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL
                                    except Exception as e:
                                        print(Fore.RED + f"Error rejoining Roblox for {package_name}: {e}" + Style.RESET_ALL)

                                update_status_table(package_statuses)

                            time.sleep(90)

                        except Exception as e:
                            print(Fore.RED + f"Critical error in auto rejoin loop: {e}" + Style.RESET_ALL)
                            time.sleep(60)
                            continue
                elif disable_check_executor == "n":
                    server_links = load_server_links()
                    accounts = load_accounts()

                    if not accounts:
                        print(Fore.RED + "No user IDs set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                        continue
                    elif not server_links:
                        print(Fore.RED + "No game ID or private server link set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                        continue

                    try:
                        force_rejoin_interval = int(input("Enter the force rejoin/kill Roblox interval in minutes: ")) * 60
                        if force_rejoin_interval <= 0:
                            raise ValueError("The interval must be a positive integer.")
                    except ValueError as ve:
                        print(Fore.RED + f"Invalid input: {ve}. Please enter a valid interval in minutes." + Style.RESET_ALL)
                        input(Fore.GREEN + "Press Enter to return to the menu..." + Style.RESET_ALL)
                        continue
                    package_statuses = {}
                    for package_name, server_link in server_links:
                        package_statuses[package_name] = {
                            "Status": Fore.LIGHTCYAN_EX + "Initializing" + Style.RESET_ALL,
                            "Username": get_username(accounts[server_links.index((package_name, server_link))][1]),
                        }

                    update_status_table(package_statuses)

                    detect_and_write_lua_script()
                    kill_roblox_processes()
                    time.sleep(5)

                    num_packages = len(server_links)

                    for package_name, server_link in server_links:
                        try:
                            package_statuses[package_name]["Status"] = Fore.LIGHTCYAN_EX + "Launching" + Style.RESET_ALL
                            update_status_table(package_statuses)
                            launch_roblox(package_name, server_link, num_packages, package_statuses)
                            package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL

                            username = get_username(accounts[server_links.index((package_name, server_link))][1])

                            reset_executor_file(username)

                            # Ensure the tool waits for the executor to load before proceeding to the next package
                            while True:
                                if check_executor_status(username, continuous=False):
                                    package_statuses[package_name]["Status"] = Fore.GREEN + f"Executor loaded successfully for {username}" + Style.RESET_ALL
                                    update_status_table(package_statuses)
                                    break  # Break the loop and proceed to the next package

                                # If the executor failed to load within 2 minutes, rejoin and retry
                                else:
                                    print(f"Executor did not load for {package_name} (username : {username}). Rejoining...")
                                    package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                    update_status_table(package_statuses)
                                    kill_roblox_process(package_name)
                                    time.sleep(2)
                                    launch_roblox(package_name, server_link, num_packages, package_statuses)

                        except Exception as e:
                            # Handle subprocess or launch error
                            print(Fore.RED + f"Error launching Roblox for {package_name}: {e}" + Style.RESET_ALL)
                            package_statuses[package_name]["Status"] = Fore.RED + "Launch failed" + Style.RESET_ALL
                        update_status_table(package_statuses)

                    start_time = time.time()

                    while True:
                        current_time = time.time()

                        try:
                            for package_name, user_id in accounts:
                                try:
                                    # Retrieve the correct server_link for the package_name
                                    server_link = get_server_link(package_name, server_links)
                                    if not server_link:
                                        package_statuses[package_name]["Status"] = Fore.RED + "Server link not found" + Style.RESET_ALL
                                        update_status_table(package_statuses)
                                        continue

                                    # Get the username associated with the user ID or fallback to user ID
                                    username = get_username_from_id(user_id)
                                    presence_type, last_location_current = check_user_online(user_id)

                                    package_statuses[package_name]["Username"] = username

                                    if presence_type == 2:
                                        package_statuses[package_name]["Status"] = Fore.GREEN + "In-Game" + Style.RESET_ALL

                                        if not check_executor_status(username, continuous=False):  # If executor isn't detected as working
                                            print(f"Executor did not update for {package_name} (username: {username}). Rejoining...")
                                            package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                            update_status_table(package_statuses)
                                            kill_roblox_process(package_name)
                                            time.sleep(2)
                                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                                    else:
                                        if not is_roblox_running(package_name):
                                            package_statuses[package_name]["Status"] = Fore.RED + "Process Crashed, Relaunching" + Style.RESET_ALL
                                            kill_roblox_process(package_name)
                                            time.sleep(2)
                                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                                            # Check executor status after relaunch
                                            if not check_executor_status(username, continuous=False):
                                                print(f"Executor did not load for {package_name} (username: {username}) after relaunch. Rejoining...")
                                                package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                                kill_roblox_process(package_name)
                                                time.sleep(2)
                                                launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        else:
                                            if last_location_current == "Website":
                                                package_statuses[package_name]["Status"] = Fore.RED + "On Website, Rejoining" + Style.RESET_ALL
                                                kill_roblox_process(package_name)
                                                time.sleep(2)
                                                launch_roblox(package_name, server_link, num_packages, package_statuses)

                                                # Check executor status after relaunch
                                                if not check_executor_status(username, continuous=False):
                                                    print(f"Executor did not load for {package_name} (username: {username}) after relaunch. Rejoining...")
                                                    package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                                    update_status_table(package_statuses)
                                                    kill_roblox_process(package_name)
                                                    time.sleep(2)
                                                    launch_roblox(package_name, server_link, num_packages, package_statuses)

                                                # If executor loaded successfully after relaunch
                                                else:
                                                    package_statuses[package_name]["Status"] = Fore.GREEN + "Executor loaded successfully after rejoin" + Style.RESET_ALL
                                                    update_status_table(package_statuses)
                                            else:
                                                package_statuses[package_name]["Status"] = Fore.YELLOW + "Not In-Game, Recently Active" + Style.RESET_ALL

                                    update_status_table(package_statuses)
                                    time.sleep(25)  # Adjust the delay time as needed

                                except Exception as e:
                                    print(Fore.RED + f"Error during rejoin process for {package_name}: {e}" + Style.RESET_ALL)
                                    package_statuses[package_name]["Status"] = Fore.RED + "General error" + Style.RESET_ALL
                                    update_status_table(package_statuses)

                            if current_time - start_time >= force_rejoin_interval:
                                print("Force killing Roblox processes due to time limit.")
                                kill_roblox_processes()
                                start_time = current_time
                                print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
                                time.sleep(5)
                                for package_name, server_link in server_links:
                                    try:
                                        package_statuses[package_name]["Status"] = Fore.RED + "Rejoining" + Style.RESET_ALL
                                        update_status_table(package_statuses)
                                        launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        # Check executor status after relaunch
                                        if not check_executor_status(username, continuous=False):
                                            print(f"Executor did not load for {package_name} (username: {username}) after rejoin. Rejoining...")
                                            package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                            kill_roblox_process(package_name)
                                            time.sleep(2)
                                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL
                                    except Exception as e:
                                        print(Fore.RED + f"Error rejoining Roblox for {package_name}: {e}" + Style.RESET_ALL)

                                update_status_table(package_statuses)

                            time.sleep(90)

                        except Exception as e:
                            print(Fore.RED + f"Critical error in auto rejoin loop: {e}" + Style.RESET_ALL)
                            time.sleep(60)
                            continue
                else:
                    print(Fore.RED + "Invalid input. Please enter 'yes' or 'no'." + Style.RESET_ALL)
            
        elif setup_type == "2":
            server_link = input("Enter the game ID or private server link: ")
            formatted_link = format_server_link(server_link)

            if formatted_link:
                packages = get_roblox_packages()
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)
                
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL)                 

        elif setup_type == "3":
            packages = get_roblox_packages()
            server_links = []

            for package_name in packages:
                server_link = input(f"Enter the game ID or private server link for {package_name}: ")
                formatted_link = format_server_link(server_link)

                if formatted_link:
                    server_links.append((package_name, formatted_link))

            save_server_links(server_links)  
            
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "4":
            clear_choice = input(Fore.GREEN + "What do you want to clear?\n1. Clear User IDs\n2. Clear Server Links\n3. Clear Both\nEnter choice: " + Style.RESET_ALL)

            if clear_choice == "1":
                if os.path.exists(ACCOUNTS_FILE):
                    os.remove(ACCOUNTS_FILE)
                    print(Fore.GREEN + "User IDs cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{ACCOUNTS_FILE}' found to clear." + Style.RESET_ALL)

            elif clear_choice == "2":
                if os.path.exists(SERVER_LINKS_FILE):
                    os.remove(SERVER_LINKS_FILE)
                    print(Fore.GREEN + "Server links cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{SERVER_LINKS_FILE}' found to clear." + Style.RESET_ALL)

            elif clear_choice == "3":
                if os.path.exists(ACCOUNTS_FILE):
                    os.remove(ACCOUNTS_FILE)
                    print(Fore.GREEN + "User IDs cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{ACCOUNTS_FILE}' found to clear." + Style.RESET_ALL)

                if os.path.exists(SERVER_LINKS_FILE):
                    os.remove(SERVER_LINKS_FILE)
                    print(Fore.GREEN + "Server links cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{SERVER_LINKS_FILE}' found to clear." + Style.RESET_ALL)
                    
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
 
        elif setup_type == "5":
            print(Fore.GREEN + "Auto Setup User IDs from each package's appStorage.json..." + Style.RESET_ALL)
            packages = get_roblox_packages()
            accounts = []

            for package_name in packages:
                file_path = f'/data/data/{package_name}/files/appData/LocalStorage/appStorage.json'
                user_id = find_userid_from_file(file_path)
                
                if user_id:
                    accounts.append((package_name, user_id))
                    print(f"Found UserId for {package_name}: {user_id}")
                else:
                    print(Fore.RED + f"UserId not found for {package_name}. Make sure the file path is correct and the format is as expected." + Style.RESET_ALL)

            save_accounts(accounts)
            save_cache()
            print(Fore.GREEN + "User IDs saved from appStorage.json!" + Style.RESET_ALL)

            # Prompt for server link
            server_link = input("Enter the game ID or private server link: ")
            formatted_link = format_server_link(server_link)

            if formatted_link:
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "6": 
            check_cookies_from_file('cookie.txt')
            input(Fore.CYAN + "Please Press Enter To Return To The main Menu..." + Style.RESET_ALL)

        elif setup_type == "7": 
            smdgEjeejCgh()

        elif setup_type == "8":
            break 

if __name__ == "__main__":
    load_cache()  # Load the cache at the start
    main()  # Run the main function
    save_cache()  # Save the cache before exiting
